package com.htmlcombiner;

import android.content.ContentResolver;
import android.net.Uri;
import android.util.Base64;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

/**
 * Combines JS + CSS (+ optional HTML template) into a single self-contained HTML file.
 *
 * Two modes:
 *   • INLINE  – wraps everything inside one HTML document using <style> and <script> tags
 *   • LINK    – produces HTML that references files via <link> / <script src=> (server must be running)
 */
public class FileCombiner {

    private final ContentResolver resolver;

    public FileCombiner(ContentResolver resolver) {
        this.resolver = resolver;
    }

    /**
     * @param items      Files to combine
     * @param pageTitle  <title> value
     * @param inlineMode true = embed content; false = link to localhost:8080
     * @param minify     basic whitespace minification
     */
    public String combine(List<FileItem> items, String pageTitle, boolean inlineMode, boolean minify) {

        // Separate files by type, preserving order
        String   htmlTemplate = null;
        List<FileItem> cssFiles  = new ArrayList<>();
        List<FileItem> jsFiles   = new ArrayList<>();

        for (FileItem fi : items) {
            if (!fi.enabled) continue;
            switch (fi.type) {
                case FileItem.TYPE_HTML:
                    // Use first HTML as template; rest ignored as HTML
                    if (htmlTemplate == null) htmlTemplate = readText(fi.uri);
                    break;
                case FileItem.TYPE_CSS:
                    cssFiles.add(fi);
                    break;
                case FileItem.TYPE_JS:
                    jsFiles.add(fi);
                    break;
            }
        }

        // ── Build or inject into template ──
        if (htmlTemplate != null) {
            return inlineMode
                    ? injectIntoTemplate(htmlTemplate, cssFiles, jsFiles, minify)
                    : linkIntoTemplate(htmlTemplate, cssFiles, jsFiles);
        }

        // ── Build from scratch ──
        return inlineMode
                ? buildInline(pageTitle, cssFiles, jsFiles, minify)
                : buildLinked(pageTitle, cssFiles, jsFiles);
    }

    // Convenience overload
    public String combine(List<FileItem> items) {
        return combine(items, "Combined App", true, false);
    }

    // ═══════════════════════════════════════════════════════
    //  INLINE mode – everything embedded
    // ═══════════════════════════════════════════════════════

    private String buildInline(String title, List<FileItem> css, List<FileItem> js, boolean minify) {
        StringBuilder sb = new StringBuilder();
        sb.append("<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n")
          .append("  <meta charset=\"UTF-8\">\n")
          .append("  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n")
          .append("  <title>").append(escHtml(title)).append("</title>\n");

        // CSS
        if (!css.isEmpty()) {
            sb.append("  <style>\n");
            sb.append("    /* ============================\n")
              .append("       Combined CSS\n")
              .append("       Generated by HTML Combiner\n")
              .append("       Files: ").append(css.size()).append("\n")
              .append("       ============================ */\n\n");
            for (FileItem fi : css) {
                String content = readText(fi.uri);
                sb.append("    /* ── ").append(fi.name).append(" ── */\n");
                sb.append(minify ? minifyCss(content) : content).append("\n\n");
            }
            sb.append("  </style>\n");
        }

        sb.append("</head>\n<body>\n\n")
          .append("  <!-- Body content here -->\n\n");

        // JS
        if (!js.isEmpty()) {
            sb.append("  <script>\n");
            sb.append("    /* ============================\n")
              .append("       Combined JavaScript\n")
              .append("       Generated by HTML Combiner\n")
              .append("       Files: ").append(js.size()).append("\n")
              .append("       ============================ */\n\n");
            for (FileItem fi : js) {
                String content = readText(fi.uri);
                sb.append("    /* ── ").append(fi.name).append(" ── */\n");
                sb.append(minify ? minifyJs(content) : content).append("\n\n");
            }
            sb.append("  </script>\n");
        }

        sb.append("</body>\n</html>");
        return sb.toString();
    }

    private String injectIntoTemplate(String html, List<FileItem> css, List<FileItem> js, boolean minify) {
        // Build CSS block
        StringBuilder cssBlock = new StringBuilder();
        for (FileItem fi : css) {
            cssBlock.append("/* ── ").append(fi.name).append(" ── */\n");
            String content = readText(fi.uri);
            cssBlock.append(minify ? minifyCss(content) : content).append("\n");
        }

        // Build JS block
        StringBuilder jsBlock = new StringBuilder();
        for (FileItem fi : js) {
            jsBlock.append("/* ── ").append(fi.name).append(" ── */\n");
            String content = readText(fi.uri);
            jsBlock.append(minify ? minifyJs(content) : content).append("\n");
        }

        // Inject before </head>
        String styleTag = "<style>\n" + cssBlock + "</style>";
        if (html.contains("</head>")) {
            html = html.replace("</head>", styleTag + "\n</head>");
        } else {
            html = styleTag + "\n" + html;
        }

        // Inject before </body>
        String scriptTag = "<script>\n" + jsBlock + "</script>";
        if (html.contains("</body>")) {
            html = html.replace("</body>", scriptTag + "\n</body>");
        } else {
            html = html + "\n" + scriptTag;
        }

        return html;
    }

    // ═══════════════════════════════════════════════════════
    //  LINK mode – references localhost:8080
    // ═══════════════════════════════════════════════════════

    private String buildLinked(String title, List<FileItem> css, List<FileItem> js) {
        StringBuilder sb = new StringBuilder();
        sb.append("<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n")
          .append("  <meta charset=\"UTF-8\">\n")
          .append("  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n")
          .append("  <title>").append(escHtml(title)).append("</title>\n");

        for (FileItem fi : css) {
            sb.append("  <link rel=\"stylesheet\" href=\"http://localhost:8080/")
              .append(fi.name).append("\">\n");
        }

        sb.append("</head>\n<body>\n\n  <!-- Body content here -->\n\n");

        for (FileItem fi : js) {
            sb.append("  <script src=\"http://localhost:8080/")
              .append(fi.name).append("\"></script>\n");
        }

        sb.append("</body>\n</html>");
        return sb.toString();
    }

    private String linkIntoTemplate(String html, List<FileItem> css, List<FileItem> js) {
        StringBuilder links   = new StringBuilder();
        StringBuilder scripts = new StringBuilder();

        for (FileItem fi : css)
            links.append("  <link rel=\"stylesheet\" href=\"http://localhost:8080/").append(fi.name).append("\">\n");

        for (FileItem fi : js)
            scripts.append("  <script src=\"http://localhost:8080/").append(fi.name).append("\"></script>\n");

        if (html.contains("</head>"))
            html = html.replace("</head>", links + "</head>");
        if (html.contains("</body>"))
            html = html.replace("</body>", scripts + "</body>");

        return html;
    }

    // ═══════════════════════════════════════════════════════
    //  Utilities
    // ═══════════════════════════════════════════════════════

    private String readText(Uri uri) {
        try (InputStream is = resolver.openInputStream(uri)) {
            if (is == null) return "/* Could not read file */";
            ByteArrayOutputStream buf = new ByteArrayOutputStream();
            byte[] tmp = new byte[4096];
            int n;
            while ((n = is.read(tmp)) != -1) buf.write(tmp, 0, n);
            return buf.toString("UTF-8");
        } catch (IOException e) {
            return "/* Error reading file: " + e.getMessage() + " */";
        }
    }

    /** Very basic CSS minifier: strip comments and collapse whitespace */
    private String minifyCss(String css) {
        css = css.replaceAll("/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/", ""); // remove comments
        css = css.replaceAll("\\s*([{}:;,>~+])\\s*", "$1");
        css = css.replaceAll("\\s+", " ").trim();
        return css;
    }

    /** Very basic JS minifier: strip single-line comments, collapse whitespace */
    private String minifyJs(String js) {
        // Remove single-line comments (be careful with URLs)
        js = js.replaceAll("(?m)(?<!:)//.*$", "");
        // Remove multi-line comments
        js = js.replaceAll("/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/", "");
        // Collapse whitespace
        js = js.replaceAll("[ \\t]+", " ");
        js = js.replaceAll("\\n+", "\n");
        return js.trim();
    }

    private String escHtml(String s) {
        return s.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;");
    }
}
